<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++中二叉树的基本操作</title>
    <url>/2020/08/22/C++%E4%B8%AD%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><strong>二叉树</strong>是一种重要的数据结构，这里记录了二叉树的几个基本操作</p>
<a id="more"></a>

<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">leafNode</span>&#123;</span>    <span class="comment">//创建叶节点结构</span></span><br><span class="line">    <span class="keyword">char</span> val;       <span class="comment">//val储存本节点数据</span></span><br><span class="line">    leafNode* left; <span class="comment">//left储存左儿子地址    </span></span><br><span class="line">    leafNode* right;<span class="comment">//right储存右儿子地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBitree</span><span class="params">(leafNode* &amp;t)</span></span>;    <span class="comment">//这里一定要使用 leafNode*&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(leafNode* &amp;t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(leafNode* &amp;t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">posOrder</span><span class="params">(leafNode* &amp;t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    leafNode* a;</span><br><span class="line">    createBitree(a);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"二叉树已创建"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    preOrder(a);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> &lt;&lt; <span class="string">"以上是先序遍历"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    inOrder(a);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> &lt;&lt; <span class="string">"以上是中序遍历"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    posOrder(a);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> &lt;&lt; <span class="string">"以上是后序遍历"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBitree</span><span class="params">(leafNode* &amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;                     <span class="comment">//临时储存要储存在节点中的数据</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">'#'</span>) t = <span class="literal">NULL</span>;      <span class="comment">//若输入为'#'，则该节点为空节点</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        t = <span class="keyword">new</span> leafNode;       <span class="comment">//创建新节点</span></span><br><span class="line">        t -&gt;val = c;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">NULL</span>) <span class="keyword">return</span>;   <span class="comment">//若该节点为空，则退出创建</span></span><br><span class="line">        createBitree(t -&gt;left); <span class="comment">//继续对该节点的左儿子，右儿子进行处理</span></span><br><span class="line">        createBitree(t -&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(leafNode* &amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t != <span class="literal">NULL</span>)&#123;              <span class="comment">//若该节点不为空，则读取该节点</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; t -&gt;val;</span><br><span class="line">        preOrder(t -&gt;left);</span><br><span class="line">        preOrder(t -&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(leafNode* &amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; t -&gt;val;</span><br><span class="line">        inOrder(t -&gt;left);</span><br><span class="line">        inOrder(t -&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">posOrder</span><span class="params">(leafNode* &amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; t -&gt;val;</span><br><span class="line">        posOrder(t -&gt;left);</span><br><span class="line">        posOrder(t -&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> # # <span class="number">4</span> # # <span class="number">5</span> <span class="number">6</span> # # #</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">二叉树已创建</span><br><span class="line"><span class="number">123456</span></span><br><span class="line">以上是先序遍历</span><br><span class="line"><span class="number">324165</span></span><br><span class="line">以上是中序遍历</span><br><span class="line"><span class="number">342651</span></span><br><span class="line">以上是后序遍历</span><br></pre></td></tr></table></figure>

<img src="map.png" alt="map" style="zoom:100%"/>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中char和int类型互化</title>
    <url>/2020/07/15/C++%E4%B8%ADchar%E5%92%8Cint%E7%B1%BB%E5%9E%8B%E4%BA%92%E5%8C%96/</url>
    <content><![CDATA[<p>1.<strong>char转为int</strong></p>
<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'6'</span>;</span><br><span class="line">    <span class="keyword">int</span> i = c - <span class="string">'0'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<hr>
<a id="more"></a>

<p>2.<strong>int转为char</strong></p>
<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">char</span> s = i + <span class="string">'0'</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中取绝对值</title>
    <url>/2020/07/16/C++%E4%B8%AD%E5%8F%96%E7%BB%9D%E5%AF%B9%E5%80%BC/</url>
    <content><![CDATA[<p>如果要在C++中取绝对值，可以使用<font color=#ff9494>stdlib.h</font>库中的<font color=#fff942>abs</font>函数。</p>
<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">-6</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">abs</span>(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的find函数</title>
    <url>/2020/08/04/C++%E4%B8%AD%E7%9A%84find%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<ol>
<li><p><strong>string</strong>的find函数</p>
<p><strong>string</strong>的find函数可用于返回某个字符第一次出现时的下标，若字符串中无该字符，则会返回一个特殊值<strong>nope</strong>（值为4294967295）</p>
<a id="more"></a>

<p><strong>样例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="built_in">string</span> s;</span><br><span class="line">   <span class="keyword">char</span> c;</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; s &gt;&gt; c;</span><br><span class="line">   <span class="keyword">if</span>(s.<span class="built_in">find</span>(c) != <span class="number">4294967295</span>)&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Nope!"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">abcde</span><br><span class="line">a</span><br><span class="line">z</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line">Nope！</span><br></pre></td></tr></table></figure>

<hr>
</li>
<li><p><strong>map</strong>的find函数</p>
<p>对于<strong>map</strong>类型的数据，对其使用find函数，其会返回一个指向要找的数据的迭代器（iterator），若改数据不存在，则会返回一个指向end的迭代器。</p>
<p><strong>样例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m1;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   m1[<span class="string">"a"</span>] = <span class="number">100</span>;</span><br><span class="line">   m1[<span class="string">"b"</span>] = <span class="number">200</span>;</span><br><span class="line">   <span class="built_in">string</span> c;</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">   <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; :: iterator it = m1.<span class="built_in">find</span>(c);</span><br><span class="line">   <span class="keyword">if</span>(it != m1.<span class="built_in">end</span>())&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Find it!"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Can't find it!"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Find it！</span><br><span class="line">Can<span class="number">'</span>t <span class="built_in">find</span> it！</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的几种容器</title>
    <url>/2020/07/19/C++%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<ol>
<li><p><strong>Vector</strong> </p>
<p>与<strong>arry</strong>相比，<strong>vector</strong>可以进行动态操作，可以随时更改长度，并且可使用迭代器进行操作。</p>
<p><strong>使用样例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;	//若要使用泛型算法，则必须包括algorithm包</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;	<span class="comment">//定义vector</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i, t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        ivec.push_back(t);	<span class="comment">//使用push_back()在vector末尾插入数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; :: iterator ivec_b = ivec.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; :: iterator ivec_e = ivec.<span class="built_in">end</span>();</span><br><span class="line">    sort(ivec_b, ivec_e);	<span class="comment">//使用sort函数对vector内数据进行从小到大排序</span></span><br><span class="line">    <span class="keyword">for</span>(; ivec_b != ivec_e; ivec_b++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *ivec_b &lt;&lt; <span class="string">' '</span>;	<span class="comment">//输出数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span> <span class="number">55</span> <span class="number">1</span> <span class="number">22</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">8</span> <span class="number">22</span> <span class="number">55</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<a id="more"></a>

<ol start="2">
<li><p><strong>Map</strong></p>
<p><strong>map</strong>被定义为一对数值，可以将其理解为每一个数据中包含了2个数值，其中<em>Key</em>通常是个字符串，扮演索引的角色，另一个数值为<em>value</em>。</p>
<p><strong>使用样例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;	//若要使用map，则必须包含map头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;	<span class="comment">//定义map</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="built_in">string</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        m[t]++;	<span class="comment">//若字符串t在m中不存在，则会将字符串t放到m内并获得默认值0，再自增是其值变为1。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; :: iterator m_b = m.<span class="built_in">begin</span>();	<span class="comment">//map同样可用迭代器操作</span></span><br><span class="line">    <span class="built_in">map</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; :: iterator m_e = m.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">for</span>(; m_b != m_e; m_b++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Key: "</span> &lt;&lt; m_b -&gt; first;	<span class="comment">//输出key</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" Value: "</span> &lt;&lt; m_b -&gt; second;	<span class="comment">//输出value</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line">ss</span><br><span class="line">aa</span><br><span class="line">ww</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Key: aa Value: <span class="number">1</span></span><br><span class="line">Key: ss Value: <span class="number">1</span></span><br><span class="line">Key: ww Value: <span class="number">1</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<ol start="3">
<li><p><strong>Set</strong></p>
<p>Set由一群<em>key</em>组成，其通常用于检查某值是否存在于某个集合内。</p>
<p><strong>使用样例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;	</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;	//若要使用set，则必须包含set头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;	<span class="comment">//定义map</span></span><br><span class="line"><span class="built_in">string</span> e[<span class="number">3</span>] = &#123;<span class="string">"serval"</span>, <span class="string">"raccoon"</span>, <span class="string">"fennec"</span>&#125;;</span><br><span class="line"><span class="built_in">set</span> &lt;<span class="built_in">string</span>&gt; <span class="keyword">word</span> (e, e + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="built_in">string</span> t, s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">word</span>.count(t))&#123;	<span class="comment">//检测输入的字符串是否在排除列表word中</span></span><br><span class="line">            <span class="keyword">continue</span>;	<span class="comment">//若在，则跳过此次迭代</span></span><br><span class="line">        &#125;</span><br><span class="line">        m[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; :: iterator m_b = m.<span class="built_in">begin</span>();	<span class="comment">//map同样可用迭代器操作</span></span><br><span class="line">    <span class="built_in">map</span> &lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; :: iterator m_e = m.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">for</span>(; m_b != m_e; m_b++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Key: "</span> &lt;&lt; m_b -&gt; first;	<span class="comment">//输出key</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" Value: "</span> &lt;&lt; m_b -&gt; second;	<span class="comment">//输出value</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line">raccoon</span><br><span class="line">owl</span><br><span class="line">serval</span><br><span class="line">fennec</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Key: owl Value: <span class="number">1</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<ol start="4">
<li><p><strong>queue</strong></p>
<p><strong>queue</strong>为队列模板，定义在<queue>头文件中</p>
<p><strong>queue模板的操作符：</strong></p>
<p><em>back()</em> 返回最后一个元素</p>
<p><em>front()</em> 返回第一个元素</p>
<p><em>pop</em>() 删除第一个元素</p>
<p><em>push()</em> 在末尾插入一个元素</p>
<p><em>empty()</em> 检查队列是否为空，是则返回true，否则返回false</p>
<p><em>size()</em> 返回队列的大小</p>
</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的iterator（迭代器）</title>
    <url>/2020/07/18/C++%E4%B8%AD%E7%9A%84iterator/</url>
    <content><![CDATA[<p><strong>摘自《Essential C++》</strong></p>
<p><em>如果 first 和 last 都是 list  的 iterator，我们可以这样写：</em></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// first和last皆为iterator class object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(first != last)&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *first &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    first++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>这就好像把 first 和 last 当作<strong>指针</strong>一样。唯一的差别在于其 *、！=、++ 运算符是由 iterator class 内相关的 inline 函数提供。对 list iterator 而言，其递增函数会沿着 list 的执政前进到下一个元素， 对 vector iterator 而言，其递增函数前进至下一个元素的方式，是将目前的地址加上一个元素的大小。</em></p>
<hr>
<a id="more"></a>

<ol>
<li>利用iterator为vector重新赋值并遍历vector</li>
</ol>
<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span> <span class="params">(<span class="number">5</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; :: iterator vec_b;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; :: iterator vec_e;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; <span class="built_in">size</span>;</span><br><span class="line">	ivec.resize(<span class="built_in">size</span>);	<span class="comment">//重新设置ivec大小</span></span><br><span class="line">	vec_b = ivec.<span class="built_in">begin</span>();</span><br><span class="line">	vec_e = ivec.<span class="built_in">end</span>();</span><br><span class="line">	<span class="keyword">for</span>(; vec_b != vec_e; vec_b++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; *vec_b;	<span class="comment">//将iterator看作指针，用*运算符提取值</span></span><br><span class="line">	&#125;</span><br><span class="line">	vec_b = ivec.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span>(; vec_b != vec_e; vec_b++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *vec_b &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中char类型数组和string的互化</title>
    <url>/2020/07/14/C++%E4%B8%AD%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B8%BA%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>1.<strong>将string类型的字符串转为char类型数组</strong></p>
<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l;</span><br><span class="line">	<span class="built_in">string</span> str = <span class="string">"Hello, World!"</span>;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line">	l = str.length();	<span class="comment">//获取str字符串长度</span></span><br><span class="line">	str.copy(s, l, <span class="number">0</span>);	<span class="comment">//str.copy(要复制到的数组，复制的字符数量，从第几个开始复制)</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; s[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>

<hr>
<a id="more"></a>

<p>2.<strong>将char类型数组转为string类型字符串</strong></p>
<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> str = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1234567890</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的链表</title>
    <url>/2020/08/10/C++%E4%B8%AD%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><strong>链表</strong>是一种常见的数据结构，其是一种非连续，非顺序的存储结构，数据元素的逻辑顺序通过指针依次连接。链表由一系列的节点（node）组成，每个节点包括两个部分，一个是储存该节点数据元素的<strong>数据域</strong>，一个是储存下一个节点地址的<strong>指针域</strong>。</p>
<a id="more"></a>

<img src="map.png" alt="map"  />

<p><strong>myLinkedlist的操作符：</strong></p>
<p>get(pos)：获得链表中第pos个节点的数据元素。</p>
<p>insert(pos, val)：在第pos个节点后添加一个数据元素为val的节点。</p>
<p>pushHead(val)：在头节点前添加一个数据元素为val的节点。</p>
<p>pushBack(val)：在尾节点后面添加一个数据元素为val的节点。</p>
<p>remove(pos)：删除第pos个节点。</p>
<p>removeHead()：删除头节点。</p>
<p>removeBack()：删除尾节点。</p>
<p>print()：打印链表。</p>
<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*为了便于操作，这里会使用一个虚拟头节点*/</span></span><br><span class="line"><span class="comment">/*为了简便，这里只举例了一部分操作符*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myLinkedlist</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">            <span class="keyword">int</span> val;</span><br><span class="line">            node* next;</span><br><span class="line">            node(<span class="keyword">int</span> val):val(val), next(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">        &#125;; </span><br><span class="line">        myLinkedlist()&#123;</span><br><span class="line">            dummyHead = <span class="keyword">new</span> node(<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pushHead</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pushTail</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">removeHead</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">removeBack</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">        node* dummyHead;    <span class="comment">//定义虚拟头节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedlist::get</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; <span class="built_in">size</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"invalid pos!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* tmp = dummyHead -&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(pos--)&#123;</span><br><span class="line">        tmp = tmp -&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tmp -&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedlist::insert</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span> || pos &gt; <span class="built_in">size</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"invalid pos!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* tmp = dummyHead;</span><br><span class="line">    node* newNode = <span class="keyword">new</span> node(val);</span><br><span class="line">    <span class="keyword">while</span>(pos--)&#123;</span><br><span class="line">        tmp = tmp -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    newNode -&gt;next = tmp -&gt;next;</span><br><span class="line">    tmp -&gt;next = newNode;</span><br><span class="line">    <span class="built_in">size</span>++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedlist::pushHead</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    node* newNode = <span class="keyword">new</span> node(val);</span><br><span class="line">    newNode -&gt;next = dummyHead -&gt;next;</span><br><span class="line">    dummyHead -&gt;next = newNode;</span><br><span class="line">    <span class="built_in">size</span>++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedlist::pushTail</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    node* tmp = dummyHead;</span><br><span class="line">    node* newNode = <span class="keyword">new</span> node(val);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">        tmp = tmp -&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    newNode -&gt;next = tmp -&gt;next;</span><br><span class="line">    tmp -&gt;next = newNode;</span><br><span class="line">    <span class="built_in">size</span>++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedlist::remove</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; <span class="number">0</span> || pos &gt; <span class="built_in">size</span> - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* tmp = dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(pos--)&#123;</span><br><span class="line">        tmp = tmp -&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    node* temp = tmp -&gt; next; </span><br><span class="line">    tmp -&gt;next = tmp -&gt;next -&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line">    <span class="built_in">size</span>--;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedlist::removeBack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="built_in">size</span>;</span><br><span class="line">    node* tmp = dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">        tmp = tmp -&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> tmp;</span><br><span class="line">    <span class="built_in">size</span>--;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedlist::removeHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">    node* tmp = dummyHead -&gt;next;</span><br><span class="line">    dummyHead -&gt;next = dummyHead -&gt;next -&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> tmp;</span><br><span class="line">    <span class="built_in">size</span>--;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    myLinkedlist node_1;</span><br><span class="line">    node_1.pushHead(<span class="number">0</span>);</span><br><span class="line">    node_1.pushHead(<span class="number">3</span>);</span><br><span class="line">    node_1.pushTail(<span class="number">66</span>);</span><br><span class="line">    node_1.removeBack();</span><br><span class="line">    node_1.removeHead();</span><br><span class="line">    node_1.insert(<span class="number">1</span>, <span class="number">99</span>);</span><br><span class="line">    node_1.<span class="built_in">get</span>(<span class="number">0</span>);</span><br><span class="line">    node_1.<span class="built_in">get</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">99</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的堆排序</title>
    <url>/2020/08/26/C++%E4%B8%AD%E7%9A%84%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapBuild</span><span class="params">(<span class="keyword">int</span> val[], <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> root)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> val[], <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">5</span>] = &#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    heapSort(num, <span class="number">5</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapBuild</span><span class="params">(<span class="keyword">int</span> val[], <span class="keyword">int</span> <span class="built_in">size</span>, <span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = root * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(left &lt; <span class="built_in">size</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> right = left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = left;</span><br><span class="line">        <span class="keyword">if</span>(right &lt; <span class="built_in">size</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val[right] &gt; val[flag])&#123;</span><br><span class="line">                flag = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val[root] &lt; val[flag])&#123;</span><br><span class="line">            swap(val[root], val[flag]);</span><br><span class="line">            heapBuild(val, <span class="built_in">size</span>, flag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> val[], <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="built_in">size</span> / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        heapBuild(val, <span class="built_in">size</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="built_in">size</span> - <span class="number">1</span>; j &gt; <span class="number">0</span>; --j)&#123;</span><br><span class="line">        swap(val[<span class="number">0</span>], val[j]);</span><br><span class="line">        heapBuild(val, j, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>算法，C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中连续读取多行字符串</title>
    <url>/2020/07/14/C++%E4%B8%AD%E8%BF%9E%E7%BB%AD%E8%AF%BB%E5%8F%96%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p><strong>C++中连续读取多行字符串</strong></p>
<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#incude<span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; s[i] &amp;&amp; s != <span class="string">'E'</span>)&#123;	<span class="comment">//当读取到E时结束输入</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++备忘录</title>
    <url>/2020/08/30/C++%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<p>将一个函数定义为<strong>内联函数</strong>可以提高程序的运行效率，将函数定义为<strong>内联函数</strong>后编译器会直接用该函数中的内容替换调用该函数的代码，以此来提高运行效率。将一个函数定义为内联函数应符合以下几点要求：</p>
<ul>
<li>代码必须为10行以内</li>
<li>不能含有循环语句</li>
<li>必须在第一次调用该函数之前将该函数定义为<strong>内联函数</strong></li>
</ul>
<hr>
<a id="more"></a>

<p><strong>find</strong>函数的用法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), numToFind); <span class="comment">//若找到，则返回指向该数的迭代器，若没找到，则返回指向vec末尾的迭代器</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>unique</strong>函数的用法与<strong>find</strong>函数类似</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">unique(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>unique函数会将vec中重复的数移到vec的末尾，从而达到去重的效果。</p>
<hr>
<p>利用<strong>中序遍历</strong>可以直接以<strong>数字大小升序</strong>输出一个<strong><em><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9" target="_blank" rel="noopener">二叉搜索树</a></em></strong></p>
<hr>
<p><strong>substr(pos, n)</strong>函数可用于拷贝一个字符串类型，<strong>pos</strong>表示从第几个下标开始，n表示拷贝几个，若pos+n大于源字符串大小，则会拷贝从<strong>pos</strong>之后所有的字符。</p>
<p><strong>实例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s = <span class="string">"abcdef"</span>;</span><br><span class="line">    <span class="built_in">string</span> s1 = s.substr(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">bcd</span><br></pre></td></tr></table></figure>



<hr>
<p><strong>C++的类和对象</strong></p>
<p>c++中的类(class)类似于c的struct，利用他可以实现构造一个数据类型。</p>
<p><strong>实例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">box</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="keyword">int</span> y;</span><br><span class="line">		<span class="keyword">int</span> z;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">getV</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> box :: getV(<span class="keyword">void</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> x * y * z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	box b1;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; b1.x &gt;&gt; b1.y &gt;&gt; b1.z;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b1.x &lt;&lt; b1.y &lt;&lt; b1.z &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; b1.getV();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>上述代码构造了一个box类型，其中包含3个成员x, y, z,和一个求体积的成员函数getV()，对于成员函数，可以在声明时直接定义函数，或者在类外使用范围解析运算符 <strong>::</strong> 定义该函数。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中无法读取静态文件的解决方法</title>
    <url>/2021/11/26/Vue%E4%B8%AD%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>这几天在修改vue-admin-template的项目时出现了一个问题</p>
<a id="more"></a>

<p><img src="2.png" alt="2"></p>
<p>我用相对路径引入了一张图片，但是在运行时无法显示，且浏览器控制台中无报错，查看浏览器中的网络窗口</p>
<p><img src="1.png" alt="1"></p>
<p>可以看到，浏览器确实读到了我在代码中设置的路径，但是就是无法显示这张图片，原因是因为VUE会动态加载js文件，js文件会被加载到内存中，若直接输入文件的地址，会导致无法访问该文件，也就无法显示该图片，如果我们查看其他文件的地址</p>
<p><img src="3.png" alt="3"></p>
<p>可以看到，其地址确实是在内存中的，因此，此时需要使用<strong>require()</strong>函数，将代码修改为如下</p>
<p><img src="4.png" alt="4"></p>
<p>刷新页面，可以看到图片已正常显示</p>
<p><img src="5.png" alt="5"></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>javaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForce695(Div.2)解题笔记</title>
    <url>/2021/01/10/CodeForce695(Div.2)%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>–</p>
<p><strong>A. Wizard of Orz</strong></p>
<p>贪心题，对于一组panel，要使其组成的数字最大，则要尽量使高位数字大，故只有首位数字为9时才可以取得最大值。而要使首位数字为9，就要使第n个panel在第10-n秒时暂停，此时得到的数为</p>
<p>9 8 7 … (10 - n) … 7 8 9，以10-n为中心向两侧递增，因为要使高位数尽量大，故只有当第8秒时暂停第二个panel才可得最大结果。</p>
<hr>
<a id="more"></a>

<p><strong>B. Hills And Valleys</strong></p>
<hr>
<p><del>CDE都不会</del></p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>CF</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello_World</title>
    <url>/2020/07/11/Hello-World/</url>
    <content><![CDATA[<p><font color=lightblue size=10><strong>Hello,World!</strong></font></p>
]]></content>
  </entry>
  <entry>
    <title>POJ3616解题笔记</title>
    <url>/2021/04/07/POJ3616%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>题目：</strong>龙鸣John由一头牛，它一共有<strong>M</strong>个产奶区间，每个区间给定开始时间<strong>a</strong>，结束时间<strong>b</strong>和产奶量<strong>c</strong>，每次挤奶后需要休息<strong>R</strong>小时，求出<strong>N</strong>小时内的最大产奶量。</p>
<a id="more"></a>

<p>上眼瞧，区间dp问题。对于牛的产奶区间，由于其在<strong>c-c+r</strong>是无法产奶的，可以直接将其所有产奶区间的结束时间<strong>b加上r</strong>，并按照开始时间a递增排序，这样，就得到了一个从有序的产奶区间表。接下来，定义dp数组dp(i)，其含义为到第i个产奶区间（包括第i个）时的最大产奶量。要求dp(i)，只需求出dp(i - 1)加上当前区间产奶量。以此类推，可以得到递推式:</p>
<p><strong>dp(i) = max(dp(i), dp(j) + d(i).c)</strong> <em>（dp(i)要初始化为d(i).c）</em></p>
<p>j的含义：对于每一个区间i，遍历其之前的区间，如果遇到与之不重合的，即d(j)的结束时间小于等于d(i)的开始时间，那么就让dp(j)加上该区间，即<em>dp(i - 1)加上当前区间产奶量</em></p>
<p><strong>AC代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1e+9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c = getchar();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">'-'</span>) w = <span class="number">-1</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">        s = s * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        c = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">9</span>) <span class="built_in">put</span>(x / <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">interval</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, r, ans = <span class="number">-1</span>;</span><br><span class="line">interval d[<span class="number">1000001</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> interval&amp; a, <span class="keyword">const</span> interval&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.a &lt; b.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line">    r = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        d[i].a = <span class="built_in">read</span>();</span><br><span class="line">        d[i].b = <span class="built_in">read</span>() + r;</span><br><span class="line">        d[i].c = <span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    sort(d, d + m, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        dp[i] = d[i].c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d[j].b &lt;= d[i].a)&#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + d[i].c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">put</span>(ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
        <category>笔记</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cocos creator中如何定义全局变量</title>
    <url>/2021/12/12/cocos%20creator%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>在cocos creator中可以通过创建用于保存数据的js，并在其他的js脚本中引入这个js并读取里面保存的数据来实现全局变量的定义。</p>
<a id="more"></a>

<p>举个例子，在复现flappy birds时，我用变量<strong>isStart</strong>来判断游戏是否开始，进而控制背景和水管是否移动。而我定义游戏的主脚本和碰撞回调函数脚本不是同一个文件，无法直接在碰撞回调脚本中修改主脚本中<strong>isStart</strong>的值，因此，可以通过定义全局变量的方法来实现参数的传递。</p>
<p>保存全局变量的脚本<strong>datas.js</strong>如下：</p>
<p><img src="1.png" alt="1"></p>
<p>保存碰撞回调函数的脚本<strong>collision.js</strong>如下：</p>
<p><img src="2.png" alt="2"></p>
<p>通过require来引入传参脚本，即可实现全局变量的导入。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Cocos Creator</tag>
      </tags>
  </entry>
  <entry>
    <title>cocos creator中碰撞回调函数没反应的解决方法</title>
    <url>/2021/12/05/cocos%20creator%E4%B8%AD%E7%A2%B0%E6%92%9E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%B2%A1%E5%8F%8D%E5%BA%94%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>最近在用cocos creator还原flappy bird的时候遇到一个问题，就是在碰撞组件无法调用回调函数，在网上查了查，发现要想正确调用回调函数要满足如下几点：</p>
<a id="more"></a>

<p><strong>1. 项目中物理引擎和碰撞引擎默认是关闭的，要先在代码中启动才可正常使用碰撞功能，启动代码如下（注意：以下代码只有放在onLoad中才有用）：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> phy_manager = cc.director.getPhysicsManager();<span class="comment">//获取物理引擎</span></span><br><span class="line">phy_manager.enabled = <span class="literal">true</span>;<span class="comment">//开启物理引擎</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> manager = cc.director.getCollisionManager();<span class="comment">//获取碰撞引擎</span></span><br><span class="line">manager.enabled = <span class="literal">true</span>;<span class="comment">//开启碰撞引擎</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 节点碰撞组件的回调函数要放在该节点的脚本中才可正常使用（我就是因为把回调函数放在初始化脚本中才导致无法使用）</strong></p>
<p><strong>具体方法如下图</strong></p>
<p><img src="1.png" alt="1"></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Cocos Creator</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中箭头函数踩的一些坑</title>
    <url>/2021/12/06/js%E4%B8%AD%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E8%B8%A9%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</url>
    <content><![CDATA[<p>今天在使用three.js中的GLTFLoader加载模型时遇到无法在load方法中使用箭头函数加载模型的问题，在网上查了很久之后才发现问题所在，<strong>即箭头函数中只能访问外部变量，而不能直接改变外部变量，想要修改外部变量的值只能调用其修改方法。</strong></p>
<p><img src="1.png" alt="1"></p>
<p>这里无法在箭头函数中直接修改_playerMarker，要用geo来传递模型中的geometry，在再下面进行定义。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>html的页面结构</title>
    <url>/2020/07/12/html%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<figure class="highlight html"><figcaption><span>html网页的页面结构</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span> <span class="comment">&lt;!-- 声明为HTML 5文档 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>这里是标题（浏览器显示的标签）<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>页面显示的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span>另一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Python爬取携程上景点评论</title>
    <url>/2021/05/13/%E5%88%A9%E7%94%A8Python%E7%88%AC%E5%8F%96%E6%90%BA%E7%A8%8B%E4%B8%8A%E6%99%AF%E7%82%B9%E8%AF%84%E8%AE%BA/</url>
    <content><![CDATA[<h2 id="利用Python爬取携程上景点评论"><a href="#利用Python爬取携程上景点评论" class="headerlink" title="利用Python爬取携程上景点评论"></a>利用Python爬取携程上景点评论</h2><a id="more"></a>

<h3 id="使用到的库："><a href="#使用到的库：" class="headerlink" title="使用到的库："></a>使用到的库：</h3><p>re</p>
<p>request</p>
<p>json</p>
<p>BeautifulSoup4</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>对于一个携程的景点评论页，在浏览器中查看其html源码，这里拿马鞍山景点小九华举例。</p>
<p><img src="pic_1.png" alt="1"></p>
<p>可以看到，这里评论的<strong>class</strong>均为<strong>commentItem</strong>，因此想到通过bs中的find_all函数寻找。但是，由于携程的评论分页是ajax请求，无法之间从html源码中换页，因此，需要从返回的json文件中获取评论信息。</p>
<p>打开Network页面，点击下一页，可以找到一个POST请求</p>
<p><img src="pic_2.png" alt="2"></p>
<p>可以看到其请求链接为<a href="https://m.ctrip.com/restapi/soa2/13444/json/getCommentCollapseList?_fxpcqlniredt=09031087213874945013" target="_blank" rel="noopener">https://m.ctrip.com/restapi/soa2/13444/json/getCommentCollapseList?_fxpcqlniredt=09031087213874945013</a>**</p>
<p>往下翻，可以找到其<strong>Request payload</strong></p>
<p><img src="pic_3.png" alt="3"></p>
<p>将其保存成json文件，读取这个python文件，每次循环修改其pageIndex值，即可访问所有分页。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'F:\\pycode\\xc_crawler\\setting.json'</span>, <span class="string">'r'</span>)</span><br><span class="line">setting = f.read()</span><br><span class="line">conten = json.loads(setting)</span><br><span class="line">res = open(<span class="string">'F:\\pycode\\xc_crawler\\res.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.108 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://m.ctrip.com/restapi/soa2/13444/json/getCommentCollapseList?_fxpcqlniredt=09031087213874945013'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">crawler</span><span class="params">()</span>:</span></span><br><span class="line">    good_review = []</span><br><span class="line">    mid_review = []</span><br><span class="line">    bad_review = []</span><br><span class="line">    cnt = int(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_reviews</span><span class="params">(self)</span>:</span></span><br><span class="line">        rq = requests.post(url, data=json.dumps(conten))</span><br><span class="line">        j = json.loads(rq.text)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(j[<span class="string">'result'</span>][<span class="string">'items'</span>])):</span><br><span class="line">            each = j[<span class="string">'result'</span>][<span class="string">'items'</span>][i]</span><br><span class="line">            c = each[<span class="string">'content'</span>]</span><br><span class="line">            comment = re.sub(<span class="string">r'&amp;#x\S\S'</span>, <span class="string">''</span>, c)</span><br><span class="line">            comment = re.sub(<span class="string">r'&amp;amp;quot;'</span>, <span class="string">''</span>, comment)</span><br><span class="line">            score = int(each[<span class="string">'score'</span>])</span><br><span class="line">            self.cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">3</span> &lt; score &lt;= <span class="number">5</span>:</span><br><span class="line">                self.good_review.append(comment)</span><br><span class="line">            <span class="keyword">elif</span> score == <span class="number">3</span>:</span><br><span class="line">                self.mid_review.append(comment)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.bad_review.append(comment)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write_to_file</span><span class="params">(self)</span>:</span></span><br><span class="line">        res.write(<span class="string">"总共找到了"</span> + str(self.cnt) + <span class="string">"条评论\n"</span>)</span><br><span class="line">        res.write(<span class="string">"\n好评：\n"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.good_review)):</span><br><span class="line">            res.write(str(i+<span class="number">1</span>) + <span class="string">":"</span> + self.good_review[i] + <span class="string">'\n'</span>)</span><br><span class="line">        res.write(<span class="string">"\n中评：\n"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.mid_review)):</span><br><span class="line">            res.write(str(i + <span class="number">1</span>) + <span class="string">":"</span> + self.mid_review[i] + <span class="string">'\n'</span>)</span><br><span class="line">        res.write(<span class="string">"\n差评：\n"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.bad_review)):</span><br><span class="line">            res.write(str(i + <span class="number">1</span>) + <span class="string">":"</span> + self.bad_review[i] + <span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">cw = crawler()</span><br><span class="line">conten[<span class="string">'arg'</span>][<span class="string">'poiId'</span>] = str(conten[<span class="string">'arg'</span>][<span class="string">'poiId'</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">    conten[<span class="string">'arg'</span>][<span class="string">"pageIndex"</span>] = str(i)</span><br><span class="line">    cw.get_reviews()</span><br><span class="line">    print(<span class="string">'正在爬取第%d页...'</span> % int(i), end=<span class="string">"\r"</span>)</span><br><span class="line">cw.write_to_file()</span><br><span class="line">res.write(<span class="string">"好评率：%.2f%%"</span> %((len(cw.good_review) / cw.cnt) * <span class="number">100</span>))</span><br><span class="line">res.close()</span><br></pre></td></tr></table></figure>



<p><strong>结果</strong></p>
<p><img src="pic_4.png" alt="4"></p>
<p><strong>参考</strong>:</p>
<p><a href="https://blog.csdn.net/m0_51271122/article/details/112238459" target="_blank" rel="noopener">https://blog.csdn.net/m0_51271122/article/details/112238459</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/27346009" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27346009</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>krusal算法的C++实现</title>
    <url>/2021/12/12/krusal%E7%AE%97%E6%B3%95%E7%9A%84C++%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p><strong>krusal</strong>算法用于解决系数图中最小生成树的问题</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 999999</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">end</span>;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (edge&amp; e)&#123;</span><br><span class="line">        <span class="keyword">return</span> weight &lt; e.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, t1, t2, t3, res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;edge&gt; <span class="title">edges</span><span class="params">(<span class="number">100</span>)</span></span>;    <span class="comment">//保存边</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">merged</span><span class="params">(<span class="number">100</span>)</span></span>;    <span class="comment">//保存每个节点属于的树</span></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; selectedEdge;  <span class="comment">//保存已选择的边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    edges.resize(m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t1 &gt;&gt; t2 &gt;&gt; t3;</span><br><span class="line">        edges[i].start = t1;</span><br><span class="line">        edges[i].<span class="built_in">end</span> = t2;</span><br><span class="line">        edges[i].weight = t3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(edge t)</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> p = merged[t.start];</span><br><span class="line">    <span class="keyword">int</span> q = merged[t.<span class="built_in">end</span>];</span><br><span class="line">    <span class="keyword">if</span>(p == q) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(merged[i] == q)&#123;</span><br><span class="line">            merged[i] = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        merged[i] = i;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; merged[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(merge(edges[i]))&#123;</span><br><span class="line">            selectedEdge.push_back(edges[i]);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; edges[i].start &lt;&lt; <span class="string">"---"</span> &lt;&lt; edges[i].<span class="built_in">end</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            res += edges[i].weight;</span><br><span class="line">            <span class="keyword">if</span>(selectedEdge.<span class="built_in">size</span>() == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2020/07/13/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p><strong>冒泡排序</strong></p>
<p>对于一个大小为N的数组，可以分别将该数组中的每一个数与其他数比较，若找到比其大/小的数，交换其位置。</p>
<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, x, buf[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; buf[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;    <span class="comment">//从数组中的第一个数开始比较</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123; </span><br><span class="line">            <span class="keyword">if</span> (buf[i] &gt; buf[j])&#123;   <span class="comment">//若找到比该数小的，交换位置</span></span><br><span class="line">                x = buf[i];</span><br><span class="line">                buf[i] = buf[j];</span><br><span class="line">                buf[j] = x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; buf[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>输入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣No.121（买股票的最佳时机）解题笔记</title>
    <url>/2020/09/15/%E5%8A%9B%E6%89%A3No.121%EF%BC%88%E4%B9%B0%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%89%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>原题</strong>：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></p>
<a id="more"></a>

<ol>
<li><p>暴力解</p>
<p>如果使用暴力算法，遍历两次数据，时间复杂度为O(n^2)，解答超时。</p>
<p><strong>暴力算法（<font color = red>超时</font>）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;prices.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[j] - prices[i] &gt; maxp) maxp = prices[j] - prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态规划</p>
<p>如果将该问题分解为子问题，即到第i天所获得的最大收益，则只需要遍历一次数据，时间复杂度为O(n)。</p>
<p><strong>动态规划</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxP = <span class="number">0</span>, mi = <span class="number">60000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            mi = <span class="built_in">min</span>(mi, prices[i]);	<span class="comment">//找到到第i天为止的最低价格</span></span><br><span class="line">            maxP = <span class="built_in">max</span>(maxP, prices[i] - mi);	<span class="comment">//计算第i天卖出的收益，若大于以前卖出的最大收益，则该收益为最大</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxP;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
        <category>笔记</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣No.67（二进制求和）解题笔记</title>
    <url>/2021/12/14/%E5%8A%9B%E6%89%A3No.67%EF%BC%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C%EF%BC%89%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><del>最近又开始写力扣了，每天一题看看能坚持多久吧</del></p>
<a id="more"></a>

<p><strong>题目</strong></p>
<p>给你两个二进制字符串，返回它们的和（用二进制表示）。</p>
<p>输入为 <strong>非空</strong> 字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p>
<p><strong>思路</strong></p>
<p>首先想到的是先将两个二进制字符串先转为十进制数相加，再转为二进制输出，但是一看数据大小，a，b长度不大于10^4，意味着转化后的十进制数的大小最大为2*10^4，超过longlong的最大表示范围，而用高精又太麻烦，因此转化的方法行不通。可以尝试通过模拟十进制加法的方法来实现二进制的加法来解该题。</p>
<p>首先先把两个字符串反转，得到尾部对其的两个二进制字符串，再进行加法，相加之后在头部补一个零，最后再进行进位判断，若头部为0，则不输出头部，若不为0则输出</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addBinary</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        reverse(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        reverse(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>()); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;=   a.<span class="built_in">size</span>())&#123;</span><br><span class="line">                res.push_back(b[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &gt;= b.<span class="built_in">size</span>())&#123;</span><br><span class="line">                res.push_back(a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res.push_back(a[i] + b[i] - <span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        res = <span class="string">"0"</span> + res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = res.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i] &gt;= <span class="string">'2'</span>)&#123;</span><br><span class="line">                res[i] -= <span class="number">2</span>;</span><br><span class="line">                res[i - <span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>] == <span class="string">'0'</span> ? res.substr(<span class="number">1</span>, res.<span class="built_in">size</span>()) : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
        <category>笔记</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣No.5（最长回文子串）解题笔记</title>
    <url>/2021/04/02/%E5%8A%9B%E6%89%A3No.5%EF%BC%88%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%EF%BC%89%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>第一眼看到<strong>1 &lt;= s.length &lt;= 1000</strong>，想到暴力解，枚举每个字串并判断是否回文，记录最长的，毫不意外地TLE了，又看了会题目，由于是最长字串问题，想到用动态规划来解。</p>
<p>对于一个长度为<strong>L</strong>的字符串S，要判断其是否为回文串，可以从两头开始判断，<strong>若S[0] = S[L]，接下来只需判断S[1]  == S[L - 1]，S[2] == S[L - 2]……S[L / 2 - 1] == S[L / 2 + 1] **，显然，这里可以使用dp数组来记录回文情况，</strong>DP(i, j)<strong>记录</strong>S[i]<strong>至</strong>S[j]**是否为回文串，这样，可以推出状态转移方程：</p>
<center>DP(i, j) = (DP(i + 1, j - 1)) && (S[i] == S[j])</center>

<a id="more"></a>

<p>对于长度为1的串，其一定是回文串，故需初始化DP(i, i) = 1</p>
<p><strong>AC代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &gt; <span class="title">dp</span><span class="params">(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(s.<span class="built_in">size</span>(), <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="built_in">string</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; s.<span class="built_in">size</span>(); l++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j + l &lt; s.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> i = l + j;</span><br><span class="line">                <span class="keyword">if</span>(l == <span class="number">1</span>)&#123;</span><br><span class="line">                    dp[j][i] = (s[i] == s[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(l == <span class="number">0</span>) dp[j][i] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[j][i] = (s[i] == s[j]) &amp;&amp; (dp[j + <span class="number">1</span>][i - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[j][i] &amp;&amp; l + <span class="number">1</span> &gt; ans.<span class="built_in">size</span>())&#123;</span><br><span class="line">                    ans = s.substr(j, l + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>这里使用了substr(j, l)函数，该函数返回字符串从j开始到j + l - 1的子串。</strong> </p>
]]></content>
      <categories>
        <category>编程</category>
        <category>笔记</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣No.332（零钱兑换）解题笔记</title>
    <url>/2020/09/13/%E5%8A%9B%E6%89%A3No.332%EF%BC%88%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%EF%BC%89%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>原题</strong>：<a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></p>
<a id="more"></a>

<p>如果直接使用回溯算法，则会超时</p>
<p><strong>回溯（<font color = red>超时</font>)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = <span class="number">10000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backTracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coins, <span class="keyword">int</span> amount, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(amount &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n &lt; <span class="built_in">min</span>) <span class="built_in">min</span> = n;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = coins.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            amount -= coins[i];</span><br><span class="line">            n++;</span><br><span class="line">            backTracking(coins, amount, n);</span><br><span class="line">            amount += coins[i];</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        sort(coins.<span class="built_in">begin</span>(), coins.<span class="built_in">end</span>());</span><br><span class="line">        backTracking(coins, amount, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span> == <span class="number">10000</span> ? <span class="number">-1</span> : <span class="built_in">min</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>对题目进行分析，可知直接使用回溯，会有多个子问题被重复计算，此情况下，可以使用备忘录记录已计算的子问题从而避免子问题的重复计算导致的超时。</p>
<p><strong>动态规划</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">flag</span> <span class="params">(amount + <span class="number">1</span>, <span class="number">0</span>)</span></span>;   <span class="comment">//创建flag用于记录取得一个金额的最少硬币数</span></span><br><span class="line">        <span class="keyword">return</span> dp(coins, amount, flag);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coins, <span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; flag)</span></span>&#123;   <span class="comment">//将dp看作取得一个金额所需的最少硬币数</span></span><br><span class="line">        <span class="keyword">if</span>(amount &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;   </span><br><span class="line">        <span class="keyword">if</span>(flag[amount] != <span class="number">0</span>) <span class="keyword">return</span> flag[amount];  <span class="comment">//若flag[amount]不为0，则说明该金额已被计算过，直接返回需要最少硬币数</span></span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mi = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i : coins)&#123;</span><br><span class="line">            <span class="keyword">int</span> subProblem = dp(coins, amount - i, flag);   <span class="comment">//计算amount-i所需最少硬币数</span></span><br><span class="line">            <span class="keyword">if</span>(subProblem == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            mi = <span class="built_in">min</span>(mi, subProblem + <span class="number">1</span>);   <span class="comment">//amount-i只需再添加一枚硬币即可凑成所需金额</span></span><br><span class="line">        &#125;</span><br><span class="line">        flag[amount] = mi == <span class="number">10000</span> ? <span class="number">-1</span> : mi; </span><br><span class="line">        <span class="keyword">return</span> mi == <span class="number">10000</span> ? <span class="number">-1</span> : mi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
        <category>编程</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>十二届蓝桥杯省赛B组C++个人题解</title>
    <url>/2021/04/20/%E5%8D%81%E4%BA%8C%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9BB%E7%BB%84C++%E4%B8%AA%E4%BA%BA%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>A</strong></p>
<a id="more"></a>

<p><img src="A.png" alt="A"></p>
<p>一眼题（<del>脑抽把kb当成1000byte了</del>） 256 x 1024 x 1024 / 4</p>
<p><strong>答案：67108864</strong></p>
<hr>
<p><strong>B</strong></p>
<p><img src="B.png" alt="B"></p>
<p>暴力就完事</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1e+9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> card[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        card[i] = <span class="number">2021</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; ; i++)&#123;</span><br><span class="line">        <span class="built_in">string</span> s = to_string(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            card[s[j] - <span class="string">'0'</span>] --;</span><br><span class="line">            <span class="keyword">if</span>(card[s[j] - <span class="string">'0'</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>答案</strong>：3181</p>
<hr>
<p><strong>C</strong></p>
<p><img src="C.png" alt="C"></p>
<hr>
<p><strong>D</strong></p>
<p><img src="D.png" alt="D"></p>
<hr>
<p><strong>E</strong></p>
<p><img src="E.png" alt="E"></p>
<hr>
<p><strong>F</strong></p>
<p><img src="F.png" alt="F"></p>
<hr>
<p><strong>G</strong></p>
<p><img src="G.png" alt="G"></p>
<p>DP题（<del>虽然在考场只写了个暴力dfs骗分</del>），定义一个二维DP[i][j]，代表前i个砝码是否可以称出重量j。</p>
<p>对于每一个砝码，其有三种状态，<strong>①放在左盘</strong>，<strong>②不取</strong>，<strong>③放在右盘</strong>，由此可以推出状态转移式：</p>
<p><strong>DP[i][j] = DP[i - 1][j - w[i]] || DP[i - 1][j] || DP[i - 1][j + w[i]] || DP[i][j]（j - w[i] &lt; 0时需要改为w[i] - j）</strong></p>
<p>再设置一下初始状态<strong>DP[i][0] = 1</strong>，之后双重循环即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1e+9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">110</span>][<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">bool</span> m[<span class="number">10010</span>];</span><br><span class="line"><span class="keyword">int</span> n, sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        sum += w[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j - w[i] &gt;= <span class="number">0</span>) dp[i][j] = dp[i][j] || dp[i - <span class="number">1</span>][j - w[i]] || dp[i - <span class="number">1</span>][j + w[i]] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = dp[i][j] || dp[i - <span class="number">1</span>][w[i] - j] || dp[i - <span class="number">1</span>][j + w[i]] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j]) m[j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sum; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m[i]) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>图的遍历</title>
    <url>/2020/09/20/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<a id="more"></a>

<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">map</span> <span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">book</span> <span class="params">(<span class="number">100</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> mi = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; mi) mi = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[cur][i] != <span class="number">-1</span> &amp;&amp; book[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            sum += <span class="built_in">map</span>[cur][i];</span><br><span class="line">            dfs(i, sum);</span><br><span class="line">            book[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">map</span>[i].resize(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) <span class="built_in">map</span>[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">map</span>[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> hei, wid, dist;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; hei &gt;&gt; wid &gt;&gt; dist;</span><br><span class="line">        <span class="built_in">map</span>[hei][wid] = dist;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mi &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>广度优先搜索（bfs）</title>
    <url>/2020/08/28/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88bfs%EF%BC%89/</url>
    <content><![CDATA[<p><strong>广度优先搜索算法</strong>（英语：Breadth-First Search，缩写为BFS），又译作<strong>宽度优先搜索</strong>，或<strong>横向优先搜索</strong>，是一种[图形搜索算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。<font color = gray><em>摘自维基百科</em></font></p>
<a id="more"></a>

<p>可以利用BFS来求二叉树的最大深度</p>
<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">leafNode</span>&#123;</span>    <span class="comment">//创建叶节点结构</span></span><br><span class="line">    <span class="keyword">char</span> val;       <span class="comment">//val储存本节点数据</span></span><br><span class="line">    leafNode* left; <span class="comment">//left储存左儿子地址    </span></span><br><span class="line">    leafNode* right;<span class="comment">//right储存右儿子地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBitree</span><span class="params">(leafNode* &amp;t)</span></span>;    <span class="comment">//这里一定要使用 leafNode*&amp;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxStep</span><span class="params">(leafNode* &amp;t)</span></span>;      <span class="comment">//定义寻找最大深度函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    leafNode* a;</span><br><span class="line">    createBitree(a);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max step of this bitree is : "</span> &lt;&lt; findMaxStep(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createBitree</span><span class="params">(leafNode* &amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;                     <span class="comment">//临时储存要储存在节点中的数据</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">'#'</span>) t = <span class="literal">NULL</span>;      <span class="comment">//若输入为'#'，则该节点为空节点</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        t = <span class="keyword">new</span> leafNode;       <span class="comment">//创建新节点</span></span><br><span class="line">        t -&gt;val = c;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">NULL</span>) <span class="keyword">return</span>;   <span class="comment">//若该节点为空，则退出创建</span></span><br><span class="line">        createBitree(t -&gt;left); <span class="comment">//继续对该节点的左儿子，右儿子进行处理</span></span><br><span class="line">        createBitree(t -&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxStep</span><span class="params">(leafNode* &amp;t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;leafNode*&gt; q;     <span class="comment">//bfs需要用到队列来储存数据</span></span><br><span class="line">    q.push(t);              <span class="comment">//将非空首节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> len = q.<span class="built_in">size</span>(); <span class="comment">//储存该层的节点数</span></span><br><span class="line">        <span class="keyword">while</span>(len)&#123;                     <span class="comment">//当遍历完该层节点后，退出循环，进入下一层</span></span><br><span class="line">            leafNode* temp = q.front(); <span class="comment">//临时储存队首节点</span></span><br><span class="line">            q.pop();                    <span class="comment">//弹出队首</span></span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left != <span class="literal">NULL</span>) q.push(temp-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right != <span class="literal">NULL</span>) q.push(temp-&gt;right);</span><br><span class="line">            len--;                     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">max</span>++;             <span class="comment">//层数加1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> # # <span class="number">5</span> # # <span class="number">3</span> #</span><br></pre></td></tr></table></figure>

<p><strong>二叉树示例</strong></p>
<p>​                 <strong>1</strong></p>
<p>​             /         \</p>
<p>​          <strong>2</strong>           <strong>3</strong>    </p>
<p>​    /             \</p>
<p><strong>4</strong>                <strong>5</strong></p>
<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Max <span class="built_in">step</span> of <span class="keyword">this</span> bitree is : <span class="number">3</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的栈</title>
    <url>/2020/07/29/%E6%A0%88/</url>
    <content><![CDATA[<p><strong>栈</strong>是一种非常常见的数据结构，其是一种后进后出的结构，即只能在一端进行插入和删除操作。</p>
<p><font color = lghtblue>可以利用<strong>栈</strong>结构来判断一个数是否为回文数</font></p>
<a id="more"></a>

<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_palindrome</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">stack</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>, i, next, l, mid;   <span class="comment">//定义top为栈的顶部</span></span><br><span class="line">    l = s.length();</span><br><span class="line">    mid = l / <span class="number">2</span> - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= mid; i++)&#123;</span><br><span class="line">        <span class="built_in">stack</span>[++top] = s[i];    <span class="comment">//将中间数之前的数全部入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mid % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        next = mid + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(mid % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">        next = mid + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = next; i &lt; l; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">stack</span>[top] != s[i])&#123;     <span class="comment">//检测栈中的数与s中的数是否一一对应</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(top == <span class="number">0</span>)&#123;   <span class="comment">//若一一对应，则不会进入if语句，top值会减至0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(is_palindrome(s))&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">" is a palindrome."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">" is not a palindrome."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">12321</span></span><br><span class="line"><span class="number">1233211</span></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">123321</span> is a palindrome.</span><br><span class="line"><span class="number">1233211</span> is <span class="keyword">not</span> a palindrome.</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>C++</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title>基于YoloV5实现AimLab GridShoot自动瞄准</title>
    <url>/2021/09/16/%E5%9F%BA%E4%BA%8EYoloV5%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84AimLab%E8%87%AA%E5%8A%A8%E7%9E%84%E5%87%86/</url>
    <content><![CDATA[<p><strong>0.思路</strong></p>
<p>在Aimlab的GridShoot项目中，所有目标均以浅蓝色的小球的形式出现，且目标和背景的颜色差别非常大。因此，可以很简单地通过YOLO训练出小球的权重模型，之后利用该模型进行识别并实现自动瞄准。</p>
<a id="more"></a>

<p><img src="23.png" alt="23"></p>
<p><strong>具体思路：游戏截图-&gt;标注小球位置-&gt;训练模型-&gt;截取屏幕-&gt;识别屏幕中的小球并获取位置-&gt;将鼠标移到小球上-&gt;点击-&gt;完成！</strong></p>
<p><strong>1.训练模型</strong></p>
<p>​    打开AimLab，进入GridShoot项目，开始后对屏幕进行截图。</p>
<p>​    保存截图后对图片进行标注，我这里使用了coco格式的标注，其数据集文件格式如下：</p>
<p>​    dataset</p>
<p>​    |___images</p>
<p>​    ……|__train</p>
<p>​    ……|__val</p>
<p>​    |___labels</p>
<p>​    ……|__train</p>
<p>​    ……|__val</p>
<p>​    其中images保存图片，labels保存标签。train中保存用于训练的数据，val中保存用于验证的数据。</p>
<p>​    图片的标签文件格式为文本，每一行代表图中的一个目标，其格式如下</p>
<p>​    <strong>数字（目标名称） 左上角的横坐标 左上角的纵坐标 长度和宽度</strong>（坐标均要归一化）</p>
<p>​     <img src="coco.png" alt="coco"></p>
<p>​    </p>
<p>​    我一共截取了5张游戏图片，其中4张作为训练集，1张作为验证集，创建好相应的label，下面即可进行模型的训练。</p>
<p>​    在YoloV5的data文件夹中创建AimLab.yaml文件，在其中设置内容如下</p>
<p>​    <img src="yaml.png" alt="yaml"></p>
<p>​    该文件中包含了训练集和验证集的路径以及分类</p>
<p>​    接下来进行训练，在YoloV5的根目录打开命令行窗口，输入如下指令</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">python train.py --img 640 --batch 8 --epochs 5 --data ./data/AimLab.yaml --cfg ./models/yolov5s.yaml --weights 'yolov5s.pt' --device '0'</span><br></pre></td></tr></table></figure>



<p>​    等待训练完成，即可看到YoloV5目录中出现一个<strong>runs</strong>文件夹，其中包括了运行的结果和其他信息</p>
<p>​    <img src="run.png" alt="run"></p>
<p>​    打开<strong>weights</strong>文件夹，其中的best.pt即是我们需要的权重文件</p>
<p>​    <img src="best.png" alt="best"></p>
<p>​    至此，我们已经完成了模型的训练，得到了权重文件，下面将需要重构YoloV5部分代码，实现利用该权重文件进行实时判断。</p>
<p>​    <strong>2.截取屏幕</strong></p>
<p>​    </p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Yolo</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序模板</title>
    <url>/2020/12/20/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> a[<span class="number">5000001</span>], sorted[<span class="number">5000001</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(l == r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		merge(l, mid);</span><br><span class="line">		merge(mid + <span class="number">1</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, t = l;</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i] &lt; a[j])&#123;</span><br><span class="line">			sorted[t] = a[i];</span><br><span class="line">			t++;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> sorted[t++] = a[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">		sorted[t] = a[i];</span><br><span class="line">		t++;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(j &lt;= r)&#123;</span><br><span class="line">		sorted[t] = a[j];</span><br><span class="line">		t++;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++)&#123;</span><br><span class="line">		a[i] = sorted[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	merge(<span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; sorted[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>输入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span> <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序(从小到大)</title>
    <url>/2020/07/17/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7)/</url>
    <content><![CDATA[<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">100</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;	<span class="comment">//left：起点，right：终点</span></span><br><span class="line">    <span class="keyword">int</span> base = num[left], i = left, j = right, temp;	<span class="comment">//base：设定基准数</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt; right)&#123;	<span class="comment">//若起点大于终点，则退出函数</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i != j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(num[j] &gt;= base &amp;&amp; j &gt; i)&#123;	<span class="comment">//从右端寻找比基准数大的数（一定要先从右端开始）</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(num[i] &lt;= base &amp;&amp; j &gt; i)&#123;	<span class="comment">//从左端开始寻找比基准数小的数</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &gt; i)&#123;	<span class="comment">//交换i和j位置的数</span></span><br><span class="line">            temp = num[i];</span><br><span class="line">            num[i] = num[j];</span><br><span class="line">            num[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    num[left] = num[i];	<span class="comment">//将基准数移至中间</span></span><br><span class="line">    num[i] = base;</span><br><span class="line">    quicksort(left, i - <span class="number">1</span>);	<span class="comment">//对基准数左侧的数再次排序</span></span><br><span class="line">    quicksort(i + <span class="number">1</span>, right);	<span class="comment">//对基准数右侧的数再次排序</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; num[i];	</span><br><span class="line">    &#125;</span><br><span class="line">    quicksort(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; num[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p><strong>输入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">7</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>摩尔投票法</title>
    <url>/2020/09/02/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><strong>摩尔投票算法</strong>是一种用来求一组数据中的众数的算法，其要求该组数据中的众数必须占该数据总数的<strong>二分之一</strong>以上。</p>
<a id="more"></a>

<p><strong>原理</strong></p>
<p>​    对于一组数来说，它的众数是唯一的，当该众数的数量超过总数的二分之一时，则可以将该众数与其余数一一抵消，最后剩下来的数一定是该众数。</p>
<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span> <span class="params">(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">6</span>&#125;)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = nums.<span class="built_in">size</span>(), pre = nums[<span class="number">0</span>], count = <span class="number">1</span>;	  <span class="comment">//cout储存pre剩余数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(nums[i] == pre) count++;				    	<span class="comment">//若遇到pre，则剩余数量加1</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            count--;								   <span class="comment">//与其他数抵消</span></span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">                pre = nums[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Mode is : "</span> &lt;&lt; pre;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mode is : <span class="number">5</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1873 砍树 解题笔记</title>
    <url>/2020/12/19/%E6%B4%9B%E8%B0%B7P1873%20%E7%A0%8D%E6%A0%91%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong><a href="https://www.luogu.com.cn/problem/P1873" target="_blank" rel="noopener">原题</a></strong></p>
<p>题干：<strong>帮助米尔科找到伐木机锯片的最大的整数高度H，使得他能得到木材至少为M米。</strong>换言之，该题要求找到<strong>至少</strong>得到<strong>M</strong>米木材的<strong>最大</strong>锯片高度<em>H</em>。</p>
<a id="more"></a>

<p>分析：显然，锯片的高度<em>H</em>存在一个可行解范围[<em>l</em>, <em>r</em>]，当<em>H</em>为<strong>0</strong>时，所有树全部被锯断，此时可以获得最大木材长度，当<em>H</em>为最高树的高度<em>T</em>时，此时可以得到最小木材长度<em>0</em>。因此可知，这个可行解的范围为[<em>0</em>, <em>T</em>]，由此可联想到可使用<strong>二分答案</strong>解决该题。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; tree;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> gain = <span class="number">0</span>;		<span class="comment">//用gain来存储获得的木材长度</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(x &lt; tree[i]) gain += <span class="built_in">abs</span>(x - tree[i]);	<span class="comment">//如果锯片高度大于第i棵树高度，获得高度x以上的木材</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> gain &gt;= m ? <span class="literal">true</span> : <span class="literal">false</span>;	<span class="comment">//如果获得的木材长度大于等于m，则高度x可行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> l, r, mid, ans = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	tree.resize(n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">cin</span> &gt;&gt; tree[i];</span><br><span class="line">	sort(tree.<span class="built_in">begin</span>(), tree.<span class="built_in">end</span>());</span><br><span class="line">	l = <span class="number">0</span>, r = tree[n - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">		mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(judge(mid))&#123;</span><br><span class="line">			l = mid + <span class="number">1</span>;</span><br><span class="line">			ans = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
        <category>笔记</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的桶排序</title>
    <url>/2020/07/13/%E7%AE%80%E5%8D%95%E7%9A%84%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>对于一个大小为N的数据，可以将一个大小为N的数组A作为储存数据的“桶”，若数据中存在数字M，则对A中的第M个桶进行标记。</p>
<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;, n, t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        data[t]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i] != <span class="number">0</span> )</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">100</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输入：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">9</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>



<p><strong>输出：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先搜索(dfs)</title>
    <url>/2020/08/19/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2(dfs)/</url>
    <content><![CDATA[<p><strong>深度优先搜索算法</strong>是一种用于遍历或搜索树或图的算法，其由约翰·霍普克罗夫特与罗伯特·塔杨发明。这个算法会尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。<font color = gray><em>摘自维基百科</em></font></p>
<a id="more"></a>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>概念</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣No.121爬楼梯解题笔记</title>
    <url>/2020/10/12/%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<p>​    <strong>原题：<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></strong></p>
<a id="more"></a>

<p>这是一道经典的动态规划题，若使用递归算法，则重复计算会过多，导致解答超时，故要使用动态规划。</p>
<p>若要爬上n阶楼梯，只需在第n-2阶时爬2阶或在n-1阶时爬一阶，以此类推，即可推出状态转移方程：</p>
<p><strong>f(x) = f(x - 1) + f(x - 2)</strong></p>
<p><strong>动态规划</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">1</span>, p = <span class="number">2</span>, r = <span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(r &lt;= n)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = q + p;</span><br><span class="line">            q = p;</span><br><span class="line">            p = temp;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>编程</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口算法</title>
    <url>/2020/09/20/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>滑动窗口算法可以用来解决一些与一连串的数字或字符有关的题目。</p>
<a id="more"></a>

<p><strong>例：<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/" target="_blank" rel="noopener">剑指 Offer 57 - II. 和为s的连续正数序列</a></strong></p>
<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findContinuousSequence</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>, sum = <span class="number">0</span>; r &lt; target; r++)&#123;</span><br><span class="line">            sum += r;</span><br><span class="line">            <span class="keyword">while</span>(sum &gt; target)&#123;</span><br><span class="line">                sum -= l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++)&#123;</span><br><span class="line">                    path.push_back(i);</span><br><span class="line">                &#125;</span><br><span class="line">                res.push_back(path);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机组成原理》阅读笔记</title>
    <url>/2020/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86_%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<ol>
<li>存储器中既保存了组成程序的指令，也保存了程序所用的数据。<font color=lghtblue><em>P10</em></font></li>
</ol>
<hr>
<ol start="2">
<li><strong>总线</strong>将计算机的多个功能单元连接在一起并允许他们相互交换数据。 <font color=lghtblue><em>P38</em></font></li>
</ol>
<hr>
<ol start="3">
<li><strong>时钟</strong>：绝大多数数字电子电路都带有一个时钟，用以生成连续的间隔固定的电脉冲流，这些电脉冲流可以来计时或确定计算机内所有事件的顺序，所以被称作时钟，时钟可以用其重复速率或频率来定义。<font color=lghblue><em>P15</em></font></li>
</ol>
<hr>
<a id="more"></a>

<ol start="4">
<li><p><strong>存储层次示意图</strong></p>
<img src="1.png" style="zoom:50%;" alt="载入失败:(" />

<p><strong>Cache：cpu中的一缓，二缓，三缓</strong></p>
<p><font color=lghtblue><em>P36</em></font></p>
</li>
</ol>
<hr>
<p>​    5.<strong>补码</strong>：在二进制算术中，求一个数补数的方法是将其各位取反并加               1。<em>如：01100101的补数为10011010 + 1 = 10011011</em></p>
<p>​    一个n位二进制数<font color=lightgreen><em>N</em></font>的二进制补码定义为 <font color=lightgreen>2<sup>n</sup> - <em>N</em></font>。若<em>N</em> = 5 =00000101，       则<em>N</em>的补码为 <font color=lightgreen>2<sup>8</sup> - 00000101 = 100000000 - 00000101 = 11111011</font>。 *    注意：11111011也可以表示 -00000101（-5）或 +123，这取决于我们    是将二进制数11111011看作补码还是非符号整数*  <font color=lghtblue><em>P53</em></font></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>《计算机网络 自顶向下方法》阅读笔记</title>
    <url>/2020/07/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C_%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>1.<strong>排队时延和分组丢失（丢包）</strong>    <font color=lghtblue><strong>P17</strong></font></p>
<p>每台分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个输出缓存（输出队列），它用于存储路由器准备发往那条链路的分组。</p>
<ul>
<li><p>排队时延</p>
<p>如果到达的分许要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待。因此，分组需要承受输出缓存的排队时延。</p>
</li>
</ul>
<ul>
<li><p>分组丢失（丢包）</p>
<p>因为缓存空间的大小是有限的，一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了，无法充入缓存，在此情况下，将出现分组丢失（丢包），到达的分组或已经排队的分组之一将被丢弃。</p>
</li>
</ul>
<hr>
<a id="more"></a>

<p>​    2.<strong>电路交换和分组交换的区别</strong>    <font color=lghtblue><strong>P15、P19</strong></font></p>
<p>​    在各种网络应用中，端系统彼此交换报文（文件、信息、数据等）。</p>
<ul>
<li><p>分组交换</p>
<p>为了从源端系统向目的系统发送一个报文，源将长报文划分为较小的数据块，每个分组通过信链路和分组交换机（路由器、链路层交换机）传送。分组以等于该链路最大传输速率的速度传输通过通信链路。</p>
</li>
<li><p>电路交换</p>
<p>在电路交换中，在端系统通信会话期间，预留了端系统间沿路径通信所需的资源（缓存、链路传输速率），而在分组交换中这些都没有预留，会话报文按需使用这些资源。<em>换言之，电路交换在进行通信前需要先接入预留的通信线路，而预留通信线路会导致可用传输速率下降</em></p>
</li>
</ul>
<hr>
<ol start="3">
<li><p><strong>传输时延和传播时延区别</strong>    <font color=lghtblue><strong>P26</strong></font></p>
<p>   <strong>传输时延</strong>是路由器推出分组所需要的时间，它是分组长度和链路传输速率的函数，而与两台路由器之间的距离无关。<em>换言之，可以将每个比特看作一辆汽车，要传输的报文看作一个由比特组成的车队，整个车队通过收费站（路由器）并被推向高速公路的时间即为传输时延。</em></p>
<p>   <strong>传播时延</strong>是一个比特从一台路由器传输到另一台路由器所需要的时间，它是两台路由器之间距离的函数。<em>换言之，一个车队（报文）从一个收费站到另一个收费站（路由器）经过的路程所用的时间即为传播时延。</em></p>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>算法备忘录</title>
    <url>/2020/10/13/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<p><strong>Floyd-Warshell算法</strong></p>
<p>该算法适用在<font color = lightblue>n x n</font>的图中于求两地的最短路径，该算法会将从a地到b地所有的中转方法算出，并将最小的路径储存在data[a][b]中。</p>
<a id="more"></a>

<p><strong>核心代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i][j] &gt; data[i][k] + data[k][j]) data[i][j] = data[i][k] + data[k][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用样例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, des, str;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"What's the size of the map(n x n): "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Which city you are in: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Which city you want to go: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; des;</span><br><span class="line">    data.resize(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">10000</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Now reading the cost from city "</span> &lt;&lt; i &lt;&lt; <span class="string">" to city "</span> &lt;&lt; j &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; data[i][j]; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(data[i][j] &gt; data[i][k] + data[k][j]) data[i][j] = data[i][k] + data[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The least cost is "</span> &lt;&lt; data[str][des];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"># <span class="number">0</span> <span class="number">3</span> #</span><br><span class="line"><span class="number">7</span> # <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> # <span class="number">12</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>Dijkstra算法</strong></p>
<p>Dijkstra算法可用于解决一个源点到其余各个顶点的最短路径的问题。</p>
<p><strong>样例</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf INT_MAX</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tar;        <span class="comment">/*储存目标源点到其余各点的距离，并用book标记从源点到该点的最小值是否已确定，若是，则为1*/</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; book;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span>, n, m, ta, min_ind = <span class="number">1</span>, str, fin, <span class="built_in">cos</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter the amounts of the points and sides: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    book.resize(n, <span class="number">0</span>);</span><br><span class="line">    mp.resize(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, inf));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) mp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter a side ( "</span> &lt;&lt; m - i &lt;&lt; <span class="string">" sides remain):"</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str &gt;&gt; fin &gt;&gt; <span class="built_in">cos</span>;</span><br><span class="line">        mp[str][fin] = <span class="built_in">cos</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Which city you are in: "</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ta;</span><br><span class="line">    book[ta] = <span class="number">1</span>;</span><br><span class="line">    tar = mp[ta];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">min</span> = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;         <span class="comment">/*寻找从源点到其余各点的最小值*/</span></span><br><span class="line">            <span class="keyword">if</span>(tar[j] &lt; <span class="built_in">min</span> &amp;&amp; book[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">min</span> = tar[j];</span><br><span class="line">                min_ind = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        book[min_ind] = <span class="number">1</span>;                  <span class="comment">/*源点到最小值点的花费已确定*/</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[min_ind][j] &lt; inf)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mp[min_ind][j] + tar[min_ind] &lt; tar[j]) tar[j] = mp[min_ind][j] + tar[min_ind];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tar[i] == inf) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"The cost from city "</span> &lt;&lt; ta &lt;&lt; <span class="string">" to city "</span> &lt;&lt; i &lt;&lt; <span class="string">" is "</span> &lt;&lt; tar[i] &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">9</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">12</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">13</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">15</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">8</span> <span class="number">4</span> <span class="number">13</span> <span class="number">17</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>vector去重</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">v.erase(unique(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>编程</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣No.1631 最小体力消耗路径 解题笔记</title>
    <url>/2021/12/15/%E5%8A%9B%E6%89%A3No.1631%20%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84%20%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>题目</strong></p>
<p>你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。</p>
<p>一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。</p>
<p>请你返回从左上角走到右下角的最小 体力消耗值 。</p>
<a id="more"></a>

<p><strong>思路</strong></p>
<p>首先看题干，知道是遍历地图类型的题，想到利用DFS或者BFS来遍历地图找到路径。而由于该题中一条路径耗费的体力值是路径上相邻格子之间<strong>高度差绝对值</strong>的<strong>最大值</strong>决定的，即为求一定范围内的最大值问题，想到用二分答案的方法来解该题，先通过二分法来获得可能的体力消耗，再通过DFS或者BFS来判断能否在不大于这个体力消耗的情况下到达终点。</p>
<p><strong>代码（BFS）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumEffortPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">9999999</span>, res = <span class="number">0</span>, mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = heights.<span class="built_in">size</span>(), m = heights[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">visited</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>))</span></span>;</span><br><span class="line">            mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">            q.push(make_pair(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">            <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">                <span class="keyword">int</span> <span class="built_in">size</span> = q.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">while</span>(<span class="built_in">size</span>--)&#123;</span><br><span class="line">                    <span class="keyword">int</span> a = q.front().first, b = q.front().second;</span><br><span class="line">                    q.pop();</span><br><span class="line">                    visited[a][b] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> t1 = a + dir[i][<span class="number">0</span>], t2 = b + dir[i][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(t1 &gt;= <span class="number">0</span> &amp;&amp; t1 &lt; n &amp;&amp; t2 &gt;= <span class="number">0</span> &amp;&amp; t2 &lt; m &amp;&amp;</span><br><span class="line">                        visited[t1][t2] == <span class="number">0</span> &amp;&amp; <span class="built_in">abs</span>(heights[t1][t2] - </span><br><span class="line">                        heights[a][b]) &lt;= mid)&#123;</span><br><span class="line">                            q.push(make_pair(t1, t2));</span><br><span class="line">                            visited[t1][t2] = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(visited[n - <span class="number">1</span>][m - <span class="number">1</span>])&#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣No.48 旋转图像解题笔记</title>
    <url>/2021/12/16/%E5%8A%9B%E6%89%A3No.48%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>题目</strong></p>
<p>给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。</p>
<a id="more"></a>

<p><strong>思路</strong></p>
<p>看到题目，首先想到沿对角线交换，交换后的矩阵仍不符合题解，此时需要再将矩阵每一行逆转，即可完成矩阵的反转。（注意：矩阵沿对角线交换时需要开一个数组记录矩阵每一个元素是否被访问，防止重复交换）</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">visited</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == i || visited[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> t = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = t;</span><br><span class="line">                visited[i][j] = visited[j][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> t = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[i][n - j - <span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
        <category>笔记</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣No.1518 换酒问题解题笔记</title>
    <url>/2021/12/17/%E5%8A%9B%E6%89%A3No.1518%20%E6%8D%A2%E9%85%92%E9%97%AE%E9%A2%98%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>题目</strong></p>
<p>小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。你购入了 numBottles 瓶酒。</p>
<p>如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。</p>
<p>请你计算 最多 能喝到多少瓶酒。</p>
<a id="more"></a>

<p><strong>思路</strong></p>
<p>用res记录喝的酒的瓶数，empty记录当前空酒瓶数，当numBottle大于0时，把酒全喝完，空瓶数加上numBottle，empty再模numExchange。</p>
<p><strong>代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int numWaterBottles(int numBottles, int numExchange) &#123;</span><br><span class="line">        int res &#x3D; 0, empty &#x3D; 0;</span><br><span class="line">        while(numBottles &gt; 0)&#123;</span><br><span class="line">            res +&#x3D; numBottles;</span><br><span class="line">            empty +&#x3D; numBottles;</span><br><span class="line">            numBottles &#x3D; empty &#x2F; numExchange;</span><br><span class="line">            empty %&#x3D; numExchange; </span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
        <category>笔记</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣No.419 甲板上的战舰解题笔记</title>
    <url>/2021/12/18/%E5%8A%9B%E6%89%A3No.419%20%E7%94%B2%E6%9D%BF%E4%B8%8A%E7%9A%84%E6%88%98%E8%88%B0%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>题目</strong></p>
<p>给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 ‘X’ 或者是一个空位 ‘.’ ，返回在甲板 board 上放置的 战舰 的数量。</p>
<p>战舰 只能水平或者垂直放置在 board 上。换句话说，战舰只能按 1 x k（1 行，k 列）或 k x 1（k 行，1 列）的形状建造，其中 k 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。</p>
<a id="more"></a>

<p><strong>思路</strong></p>
<p>又是遍历地图类型的题，使用DFS来遍历地图，visited数组来记录每一个元素是否已经经过，遍历地图的每一个元素，若遇到‘X’，结果res自增，进入深搜，找到所有与该点有通路的其余‘X’，并将所有有通路的元素设置为‘X’。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; visited;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countBattleships</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        visited.resize(board.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(board[<span class="number">0</span>].<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'X'</span>)&#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    dfs(i, j, board);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= visited.<span class="built_in">size</span>() || y &lt; <span class="number">0</span> || y &gt;= visited[<span class="number">0</span>].<span class="built_in">size</span>() || board[x][y] == <span class="string">'.'</span> || visited[x][y] == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = <span class="string">'.'</span>;</span><br><span class="line">        visited[x][y] = <span class="number">1</span>;</span><br><span class="line">        dfs(x + <span class="number">1</span>, y, board);</span><br><span class="line">        dfs(x, y + <span class="number">1</span>, board);</span><br><span class="line">        dfs(x - <span class="number">1</span>, y, board);</span><br><span class="line">        dfs(x, y - <span class="number">1</span>, board);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
        <category>笔记</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣No.997 找到小镇的法官解题笔记</title>
    <url>/2021/12/19/%E5%8A%9B%E6%89%A3No.997%20%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>题目</strong></p>
<p>在一个小镇里，按从 1 到 n 为 n 个人进行编号。传言称，这些人中有一个是小镇上的秘密法官。</p>
<p>如果小镇的法官真的存在，那么：</p>
<p>小镇的法官不相信任何人。<br>每个人（除了小镇法官外）都信任小镇的法官。<br>只有一个人同时满足条件 1 和条件 2 。<br>给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示编号为 a 的人信任编号为 b 的人。</p>
<p>如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的编号。否则，返回 -1。</p>
<a id="more"></a>

<p><strong>思路</strong></p>
<p>一眼模拟题，开一个二维数组记录每两个人之间的信任情况，先按列遍历，找到被所有人信任的人的编号，再遍历这个人的所有列，判断是否不信任所有人，若两个都满足，则这个人就是法官。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findJudge</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trust)</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">map</span> <span class="params">(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; trust.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">          <span class="built_in">map</span>[trust[i][<span class="number">0</span>]][trust[i][<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">          <span class="keyword">int</span> f1 = <span class="number">1</span>, f2 = <span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">              <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">              <span class="keyword">if</span>(<span class="built_in">map</span>[j][i] == <span class="number">0</span>)&#123;</span><br><span class="line">                  f1 = <span class="number">0</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(f1)&#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                  <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">                  <span class="keyword">if</span>(<span class="built_in">map</span>[i][j] == <span class="number">1</span>) f2 = <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(f1 &amp;&amp; f2) res = i;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>编程</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣No.475 供暖器解题笔记</title>
    <url>/2021/12/20/%E5%8A%9B%E6%89%A3No.475%20%E4%BE%9B%E6%9A%96%E5%99%A8%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>题目</strong></p>
<p>冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。</p>
<p>在加热器的加热半径范围内的每个房屋都可以获得供暖。</p>
<p>现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。</p>
<p>说明：所有供暖器都遵循你的半径标准，加热的半径也一样。</p>
<a id="more"></a>

<p><strong>思路</strong></p>
<p>供暖器半径为0至最远的房屋的位置，由于答案的范围已经确定，因此可以想到利用二分答案的方法来解该题。</p>
<p>对于check函数的实现，可以采用以下思路：</p>
<p>先将houses和heaters按升序排序，对于一个radius，要确定是否有效，需要确定每一个房屋的最近的供暖器的作用范围是否可以覆盖这个房屋。一个房屋<strong>无法</strong>被其最近供暖器覆盖的条件如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">houses[i] &gt; heater[j] + r || houses[i] &lt; heater[j] - r</span><br></pre></td></tr></table></figure>

<p>因此需要遍历每一个房屋，找到离其最近的供暖器，确定该房屋是否可以被最近的供暖器覆盖。由此可以使用双指针法，指针<strong>i</strong>指向房屋，指针<strong>j</strong>指向供暖器，依次找到离每个房屋最近的供暖器，判断是否可以覆盖，若有一个房屋无法覆盖，则说明该<strong>radius</strong>无效，返回<strong>false</strong>，若遍历完所有房屋，则说明所有房屋都可被覆盖，此时返回<strong>true</strong>。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; houses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; heaters, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; houses.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; heaters.<span class="built_in">size</span>() &amp;&amp; houses[i] &gt; heaters[j] + r) j++;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= heaters.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(houses[i] &lt; heaters[j] - r || houses[i] &gt; heaters[j] + r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">findRadius</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; houses, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heaters)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">1000000000</span>, res = <span class="number">1000000000</span>;</span><br><span class="line">        sort(houses.<span class="built_in">begin</span>(), houses.<span class="built_in">end</span>());</span><br><span class="line">        sort(heaters.<span class="built_in">begin</span>(), heaters.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(houses, heaters, mid))&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                res = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
        <category>笔记</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣No.1154 一年中的第几天解题笔记</title>
    <url>/2021/12/21/%E5%8A%9B%E6%89%A3No.1154%20%E4%B8%80%E5%B9%B4%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9%E8%A7%A3%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>题目</strong></p>
<p>给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。请你计算并返回该日期是当年的第几天。</p>
<p>通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。</p>
<a id="more"></a>

<p><strong>思路</strong></p>
<p>简单的字符串分割，先分别用<strong>substr</strong>获取年月日，再判断是不是闰年，之后将当前月份之前的月份天数相加，最后输出相加的结果加上当前的天数。</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isR</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x % <span class="number">400</span> == <span class="number">0</span> || (x % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; x % <span class="number">100</span> != <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> monL[<span class="number">13</span>] = &#123;<span class="number">0</span>,<span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> monNotL[<span class="number">13</span>] = &#123;<span class="number">0</span>,<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dayOfYear</span><span class="params">(<span class="built_in">string</span> date)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> year = stoi(date.substr(<span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">        <span class="keyword">int</span> month = stoi(date.substr(<span class="number">5</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">int</span> day = stoi(date.substr(<span class="number">8</span>, <span class="number">2</span>));</span><br><span class="line">        <span class="keyword">if</span>(isR(year))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; month; i++)&#123;</span><br><span class="line">                res += monL[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; month; i++)&#123;</span><br><span class="line">                res += monNotL[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + day;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
        <category>笔记</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
</search>
